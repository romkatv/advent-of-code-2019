#!/usr/bin/env zsh

emulate -L zsh
setopt no_aliases err_return no_unset extended_glob pipe_fail warn_create_global
setopt ksh_arrays

zmodload zsh/mathfunc

(( ARGC == 1 ))

local -r num="(-<0-$((1<<31))>|<0-$((1<<31-1))>)"

local -a mem
IFS=, read -rA mem <<<$1
[[ -z "${(@)mem:#$~num}" ]]

local -i p mode

function at() {
  (( $1 >= 0 && $1 < ${#mem[@]} ))
  typeset -gi $2=${mem[$1]}
}

function next() {
  at $p $1
  (( ++p ))
}

function fetch() {
  while (( ARGC )); do
    local -i res m
    next res
    (( m = mode % 10, 1 ))
    (( mode /= 10, 1 ))
    if (( m == 0 )); then
      at $res res
    else
      (( m == 1 ))
    fi
    typeset -gi $1=$res
    shift
  done
}

function store() {
  local -i pos
  next pos
  (( mode % 10 == 0 ))
  (( mode /= 10, 1 ))
  (( pos >= 0 && pos < ${#mem[@]} ))
  [[ $1 == $~num ]]
  mem[pos]=$1
}

[[ -z "${functions[(I)op_<->]}" ]]

function op_99() {
  exit 0
}

function op_1() {
  local -i a b
  fetch a b
  store $((a + b))
}

function op_2() {
  local -i a b
  fetch a b
  store $((a * b))
}

function op_3() {
  local a
  read -r a
  [[ $a == $~num ]]
  store $a
}

function op_4() {
  local -i a
  fetch a
  echo -E - $a
}

local -i instr
while true; do
  next instr
  mode=$((instr / 100))
  local op=op_$((instr % 100))
  (( ${+functions[$op]} ))
  $op
  (( mode == 0 ))
done
