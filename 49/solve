#!/usr/bin/env zsh

emulate -L zsh
setopt no_aliases err_exit no_unset extended_glob pipe_fail warn_create_global

zmodload zsh/zpty

function ascii-encode() {
  local c
  while read -rku0 c && [[ -n $c ]]; do
    echo $((#c))
  done
}

function ascii-decode() {
  local line
  while read -r line; do
    [[ $line == <1-127> ]]
    printf \\$(([##8]line))
  done
}

() {
  local program REPLY
  zpty z "{ ascii-encode | ./icc ${(q)"$(<&0)"} | ascii-decode } 2>&3" 3>&2
}
trap 'zpty -d z' EXIT

local line

function readline() {
  while true; do
    zpty -r z line
    line=${line%$'\r\n'}
    [[ ! -o xtrace || $line != '+(zpty):'* ]] || continue
    return
  done
}

function send() { zpty -w z $1 }

function receive() {
  while [[ $line != (#b)$~1 ]] readline
  line=
}

local -rA reverse=(
  'east' 'west'
  'west' 'east'
  'south' 'north'
  'north' 'south')

local -ra bad=(
  'giant electromagnet'
  'infinite loop'
  'escape pod'
  'molten lava'
  'photons')

local -a visited items checkpoint

function explore() {
  local match mbegin mend
  receive '\=\= (*) \=\='
  local room=$match[1]
  (( !visited[(I)$room] )) || return 0

  visited+=$room

  receive 'Doors here lead:'
  local -a doors
  while true; do
    readline
    [[ $line == (#b)'- '(*) ]] || break
    doors+=$match[1]
  done
  (( $#doors ))

  receive '(Items here:)|(Command?)'
  if [[ -n $match[1] ]]; then
    while true; do
      readline
      [[ $line == (#b)'- '(*) ]] || break
      local item=$match[1]
      if (( !bad[(I)$item] )); then
        send "take $item"
        items+=$item
      fi
    done
  fi

  if [[ $room == 'Security Checkpoint' ]]; then
    (( $# ))
    (( $#doors == 2 ))
    local back=$reverse[${*[-1]}]
    (( ${#doors:#$back} == 1 ))
    checkpoint=($* ${doors:#$back})
    return
  fi

  local fwd
  for fwd in $doors; do
    local back=$reverse[$fwd]
    [[ $back != ${*[-1]-} ]] || continue
    send $fwd
    explore $* $fwd
    send $back
    receive "\=\= $room \=\="
  done
}

explore
(( $#checkpoint > 1 && $#items > 0 ))
send ${(F)checkpoint[1,-2]}
receive '\=\= Security Checkpoint \=\='

function popcount() {
  local -i a=$1 res
  while (( a )); do
    (( a >>= 1, ++res ))
  done
  unsetopt err_exit
  return res
}
functions -M popcount 1

() {
  local -A checked
  local match mbegin mend k v
  local -i mask i inventory=$((1 << $#items - 1))

  while true; do
    local -i diff=$((1 << ($#items+1) - 1))
    for mask in {0..$((1 << $#items - 1))}; do
      [[ ! -v "checked[$mask]" ]] || continue
      for k v in ${(kv)checked}; do
        if { (( mask & k == k ))    && [[ $v == lighter ]] } ||
          { (( mask & k == mask )) && [[ $v == heavier ]] }; then
          checked[$mask]=$v
          break
        fi
      done
      [[ ! -v "checked[$mask]" ]] || continue
      (( popcount(inventory ^ mask) >= popcount(diff) )) || diff='inventory ^ mask'
    done
    (( popcount(diff) <= $#items ))

    for i in {1..$#items}; do
      (( diff & (1 << (i-1)) )) || continue
      if (( inventory & (1 << (i-1)) )); then
        send "drop $items[i]"
      else
        send "take $items[i]"
      fi
    done
    (( inventory ^= diff, 1 ))

    send $checkpoint[-1]
    receive '*(get in by typing ([0-9]#)|(lighter|heavier) than the detected)*'
    if [[ -n $match[2] ]]; then
      echo -E - $match[2]
      return
    fi
    checked[$inventory]=$match[3]
  done

  return 1
}
